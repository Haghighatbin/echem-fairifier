"""
FAIR metadata generation for electrochemical data.
"""

import yaml
from datetime import datetime
from typing import Dict, Any, Optional, List
import uuid


class FAIRMetadataGenerator:
    """Generate FAIR-compliant metadata for electrochemical experiments."""

    def __init__(self):
        self.required_fields = [
            "technique",
            "working_electrode",
            "reference_electrode",
            "counter_electrode",
            "electrolyte",
        ]

    def generate_metadata(
        self,
        technique: str,
        technique_parameters: Dict[str, Any],
        experimental_details: Dict[str, str],
        dataset_info: Dict[str, str],
        additional_metadata: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """
        Generate comprehensive FAIR metadata.

        Args:
            technique: Electrochemical technique name
            technique_parameters: Dictionary of technique-specific parameters
            experimental_details: Electrode and electrolyte information
            dataset_info: Information about the data file
            additional_metadata: Optional additional metadata fields

        Returns:
            Complete metadata dictionary
        """
        # Generate unique identifier
        experiment_id = str(uuid.uuid4())

        # Base metadata structure
        metadata = {
            # FAIR Identifiers
            "experiment_id": experiment_id,
            "created_date": datetime.now().isoformat(),
            "schema_version": "1.0.0",
            # Technique Information
            "technique": {
                "name": technique,
                "description": self._get_technique_description(technique),
                "parameters": technique_parameters,
            },
            # Experimental Setup
            "experimental_setup": {
                "working_electrode": experimental_details.get("working_electrode", ""),
                "reference_electrode": experimental_details.get(
                    "reference_electrode", ""
                ),
                "counter_electrode": experimental_details.get("counter_electrode", ""),
                "electrolyte": experimental_details.get("electrolyte", ""),
                "temperature": experimental_details.get(
                    "temperature", "Room temperature"
                ),
                "atmosphere": experimental_details.get("atmosphere", "Air"),
            },
            # Dataset Information
            "dataset": {
                "filename": dataset_info.get("filename", ""),
                "format": "CSV",
                "encoding": "UTF-8",
                "columns_expected": self._get_expected_columns(technique),
                "description": f"{technique} electrochemical measurement data",
            },
            # FAIR Compliance
            "fair_compliance": {
                "findable": {
                    "unique_identifier": experiment_id,
                    "metadata_standard": "EChem-FAIR v1.0",
                },
                "accessible": {
                    "access_protocol": "File download",
                    "format": "Open format (CSV, YAML)",
                },
                "interoperable": {
                    "metadata_vocabulary": "EMMO Electrochemistry Domain",
                    "data_format_standard": "CSV with standardized headers",
                },
                "reusable": {
                    "license": experimental_details.get("license", "CC-BY-4.0"),
                    "provenance": "Generated by EChem FAIRifier",
                    "quality_assessment": "Automated validation applied",
                },
            },
            # Contact and Attribution
            "attribution": {
                "creator": experimental_details.get("creator", ""),
                "institution": experimental_details.get("institution", ""),
                "contact_email": experimental_details.get("contact_email", ""),
                "orcid": experimental_details.get("orcid", ""),
            },
            # Related Publications/Data
            "related_work": {
                "publication_doi": experimental_details.get("publication_doi", ""),
                "related_datasets": experimental_details.get("related_datasets", []),
                "funding_source": experimental_details.get("funding_source", ""),
            },
        }

        # Add any additional metadata
        if additional_metadata:
            metadata.update(additional_metadata)

        return metadata

    def generate_yaml(self, metadata: Dict[str, Any]) -> str:
        """Convert metadata dictionary to YAML string."""
        return yaml.dump(
            metadata,
            default_flow_style=False,
            sort_keys=False,
            indent=2,
            allow_unicode=True,
        )

    def validate_metadata(self, metadata: Dict[str, Any]) -> Dict[str, List[str]]:
        """
        Validate metadata completeness and return issues.

        Returns:
            Dictionary with 'errors' and 'warnings' lists
        """
        errors = []
        warnings = []

        # Check required fields
        exp_setup = metadata.get("experimental_setup", {})
        for field in self.required_fields:
            if field == "technique":
                if not metadata.get("technique", {}).get("name"):
                    errors.append(f"Missing required field: {field}")
            elif not exp_setup.get(field):
                errors.append(f"Missing required field: {field}")

        # Check for empty values
        technique_params = metadata.get("technique", {}).get("parameters", {})
        if not technique_params:
            warnings.append("No technique parameters specified")

        # Check attribution completeness
        attribution = metadata.get("attribution", {})
        if not attribution.get("creator"):
            warnings.append("No creator specified - important for attribution")

        if not attribution.get("institution"):
            warnings.append("No institution specified")

        # Check licensing
        fair_compliance = metadata.get("fair_compliance", {})
        reusable = fair_compliance.get("reusable", {})
        if not reusable.get("license") or reusable.get("license") == "":
            warnings.append("No license specified - may limit reusability")

        return {"errors": errors, "warnings": warnings}

    def _get_technique_description(self, technique: str) -> str:
        """Get description for the technique."""
        descriptions = {
            "CV": "Cyclic voltammetry with triangular potential waveform",
            "DPV": "Differential pulse voltammetry with pulse modulation",
            "SWV": "Square wave voltammetry with square wave modulation",
            "EIS": "Electrochemical impedance spectroscopy with AC perturbation",
            "CA": "Chronoamperometry with potential step(s)",
        }
        return descriptions.get(technique, f"{technique} electrochemical measurement")

    def _get_expected_columns(self, technique: str) -> List[str]:
        """Get expected column names for the technique."""
        column_mapping = {
            "CV": ["Potential (V)", "Current (A)", "Cycle"],
            "DPV": ["Potential (V)", "Current (A)", "Pulse"],
            "SWV": [
                "Potential (V)",
                "Current (A)",
                "Forward Current (A)",
                "Reverse Current (A)",
            ],
            "EIS": ["Frequency (Hz)", "Z_real (Ohm)", "Z_imag (Ohm)", "Phase (deg)"],
            "CA": ["Time (s)", "Current (A)", "Potential (V)"],
        }
        return column_mapping.get(technique, ["Potential (V)", "Current (A)"])

    def create_minimal_metadata(
        self, technique: str, parameters: Dict[str, Any], filename: str
    ) -> Dict[str, Any]:
        """Create minimal metadata for quick generation."""
        return {
            "technique": technique,
            "technique_parameters": parameters,
            "dataset_link": filename,
            "created_date": datetime.now().isoformat(),
            "schema_version": "1.0.0-minimal",
        }
